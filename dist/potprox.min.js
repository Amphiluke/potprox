(function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?this:self:global:window,b.potprox=a()}})(function(){return function b(c,d,e){function a(h,i){if(!d[h]){if(!c[h]){var j="function"==typeof require&&require;if(!i&&j)return j(h,!0);if(g)return g(h,!0);var k=new Error("Cannot find module '"+h+"'");throw k.code="MODULE_NOT_FOUND",k}var f=d[h]={exports:{}};c[h][0].call(f.exports,function(b){var d=c[h][1][b];return a(d?d:b)},f,f.exports,b,c,d,e)}return d[h].exports}for(var g="function"==typeof require&&require,f=0;f<e.length;f++)a(e[f]);return a}({1:[function(a,b){let c=new WeakMap;class d{constructor({d0:b=1,r0:d=1,a:e=2}={}){c.set(this,{}),this.d0=b,this.r0=d,this.a=e}static fastFrom(b){if(!Array.isArray(b))throw new TypeError("Approximated data should be an array of points");if(3>b.length)throw new Error("Too little points. Approximation is impossible");b=b.slice().sort((a,b)=>a.r-b.r);let c=Number.POSITIVE_INFINITY,f=1;for(let{r:a,e:d}of b)d<c&&(c=d,f=a);c=Math.abs(c);let e,g;for(let a=1;a<b.length&&(e=b[a-1],g=b[a],!(g.r>=f||0>e.e||0>g.e));a++);let h;if(e&&g&&e.r<f&&g.r<=f){let a=e.e*(e.r-g.r)/(g.e-e.e)+e.r;if(0<a){let b=1-a/f,c=Math.pow(f/a,6)/6;h=(c-b-Math.sqrt(c*c-2*b*c-b*b))/(b*b),Number.isFinite(h)||(h=void 0)}}return new d({d0:c,r0:f,a:h})}static from(b,{d0Conv:c=1e-3,r0Conv:d=1e-3,aConv:e=1e-3}={}){let f=this.fastFrom(b),{d0:g,r0:h,a:i}=f;const a=g*c,j=h*d,k=i*e;let l,m,n;do{let a=0,c=0,d=0,f=0,j=0,o=0,p=0,q=0,s=0;for(let{r:t,e:r}of b){let b=i*Math.pow(h/t,6),e=Math.exp(i*(1-t/h)),u=g/(i-6)*(6*e-b),k=u/g,l=g/(i-6)*(6*e*i*t/(h*h)-6*b/h),m=-g/((i-6)*(i-6))*(6*e-b)+g/(i-6)*(6*(1-t/h)*e-b/i);a+=k*k,c+=l*k,d+=m*k,f+=(u-r)*k,j+=l*l,o+=m*l,p+=(u-r)*l,q+=m*m,s+=(u-r)*m}n=-(f-a*p/c-(f-a*s/d)*((c-a*j/c)/(c-a*o/d)))/(d-a*o/c-(d-a*q/d)*(c-a*j/c)/(c-a*o/d)),m=((d-a*o/c)*n+(f-a*p/c))/(a*j/c-c),l=(-c*m-d*n-f)/a,g+=l,h+=m,i+=n}while(Math.abs(l)>a&&Math.abs(m)>j&&Math.abs(n)>k);return f.d0=g,f.r0=h,f.a=i,f}get d0(){return c.get(this).d0}set d0(a){if(!Number.isFinite(a))throw new TypeError("The 'd0' parameter should be a finite number");if(0>=a)throw new RangeError("The 'd0' parameter should be greater than zero");c.get(this).d0=a}get r0(){return c.get(this).r0}set r0(a){if(!Number.isFinite(a))throw new TypeError("The 'r0' parameter should be a finite number");if(0>=a)throw new RangeError("The 'r0' parameter should be greater than zero");c.get(this).r0=a}get a(){return c.get(this).a}set a(a){if(!Number.isFinite(a))throw new TypeError("The 'a' parameter should be a finite number");if(0>=a)throw new RangeError("The 'a' parameter should be greater than 0");c.get(this).a=a}at(b){if("number"!=typeof b)throw new TypeError("Distance should be a number");if(0>b)throw new RangeError("Distance shouldn't be less than zero");let{d0:c,r0:d,a:e}=this;return c/(e-6)*(6*Math.exp(e*(1-b/d))-e*Math.pow(d/b,6))}toJSON(){return{type:"Buckingham",d0:this.d0,r0:this.r0,a:this.a}}}b.exports=d},{}],2:[function(a,b){let c=new WeakMap;class d{constructor({epsilon:a=1,sigma:b=1}={}){c.set(this,{}),this.epsilon=a,this.sigma=b}static from(c){if(!Array.isArray(c))throw new TypeError("Approximated data should be an array of points");if(3>c.length)throw new Error("Too little points. Approximation is impossible");let f=0,g=0,h=0,i=0,j=0;for(let{r:a,e:b}of c)f+=Math.pow(a,-24),g+=Math.pow(a,-18),h+=b*Math.pow(a,-12),i+=Math.pow(a,-12),j+=b*Math.pow(a,-6);let e=(j-g*h/f)/(i-g*g/f),b=(h-g*e)/f,k=Math.pow(-b/e,1/6),l=b/(4*Math.pow(k,12));return new d({epsilon:l,sigma:k})}get epsilon(){return c.get(this).epsilon}set epsilon(a){if(!Number.isFinite(a))throw new TypeError("The 'epsilon' parameter should be a finite number");if(0>=a)throw new RangeError("The 'epsilon' parameter should be greater than zero");c.get(this).epsilon=a}get sigma(){return c.get(this).sigma}set sigma(a){if(!Number.isFinite(a))throw new TypeError("The 'sigma' parameter should be a finite number");if(0>=a)throw new RangeError("The 'sigma' parameter should be greater than zero");c.get(this).sigma=a}get r0(){return 1.122462048309373*this.sigma}set r0(a){this.sigma=a/1.122462048309373}at(a){if("number"!=typeof a)throw new TypeError("Distance should be a number");if(0>a)throw new RangeError("Distance shouldn't be less than zero");let{epsilon:b,sigma:c}=this;return 4*b*(Math.pow(c/a,12)-Math.pow(c/a,6))}toJSON(){return{type:"LennardJones",epsilon:this.epsilon,sigma:this.sigma}}}b.exports=d},{}],3:[function(a,b){let c=new WeakMap;class d{constructor({d0:b=1,r0:d=1,a:e=1}={}){c.set(this,{}),this.d0=b,this.r0=d,this.a=e}static fastFrom(b){if(!Array.isArray(b))throw new TypeError("Approximated data should be an array of points");if(3>b.length)throw new Error("Too little points. Approximation is impossible");let c=Number.POSITIVE_INFINITY,f=1;for(let{r:a,e:d}of b)d<c&&(c=d,f=a);c=Math.abs(c);let g=0,h=0;for(let{r:a,e:d}of b){let b=Math.sqrt(1+d/c),e=Number.NaN;a>f?e=Math.log(1-b)/(f-a):a<f&&(e=Math.log(1+b)/(f-a)),Number.isFinite(e)&&(g+=e,h++)}return g/=h,new d({d0:c,r0:f,a:g})}static from(b,{d0Conv:c=1e-3,r0Conv:d=1e-3,aConv:e=1e-3}={}){let f=this.fastFrom(b),{d0:g,r0:h,a:i}=f;const a=g*c,j=h*d,k=i*e;let l,m,n;do{let a=0,c=0,d=0,f=0,j=0,o=0,p=0,q=0,s=0;for(let{r:t,e:r}of b){let b=Math.exp(i*(h-t)),e=-g+g*(1-b)*(1-b),k=e/g,l=-2*g*(1-b)*i*b,m=2*g*(1-b)*(t-h)*b;a+=k*k,c+=l*k,d+=m*k,f+=(e-r)*k,j+=l*l,o+=m*l,p+=(e-r)*l,q+=m*m,s+=(e-r)*m}n=-(f-a*p/c-(f-a*s/d)*((c-a*j/c)/(c-a*o/d)))/(d-a*o/c-(d-a*q/d)*(c-a*j/c)/(c-a*o/d)),m=((d-a*o/c)*n+(f-a*p/c))/(a*j/c-c),l=(-c*m-d*n-f)/a,g+=l,h+=m,i+=n}while(Math.abs(l)>a&&Math.abs(m)>j&&Math.abs(n)>k);return f.d0=g,f.r0=h,f.a=i,f}get d0(){return c.get(this).d0}set d0(a){if(!Number.isFinite(a))throw new TypeError("The 'd0' parameter should be a finite number");if(0>=a)throw new RangeError("The 'd0' parameter should be greater than zero");c.get(this).d0=a}get r0(){return c.get(this).r0}set r0(a){if(!Number.isFinite(a))throw new TypeError("The 'r0' parameter should be a finite number");if(0>=a)throw new RangeError("The 'r0' parameter should be greater than zero");c.get(this).r0=a}get a(){return c.get(this).a}set a(a){if(!Number.isFinite(a))throw new TypeError("The 'a' parameter should be a finite number");if(0>=a)throw new RangeError("The 'a' parameter should be greater than zero");c.get(this).a=a}at(b){if("number"!=typeof b)throw new TypeError("Distance should be a number");if(0>b)throw new RangeError("Distance shouldn't be less than zero");let{d0:c,r0:d,a:e}=this,a=1-Math.exp(e*(d-b));return c*a*a-c}toJSON(){return{type:"Morse",d0:this.d0,r0:this.r0,a:this.a}}}b.exports=d},{}],4:[function(a,b){let c=new WeakMap;class d{constructor({d0:a=1,r0:d=1,b:e=2}={}){c.set(this,{}),this.d0=a,this.r0=d,this.b=e}static fastFrom(a){if(!Array.isArray(a))throw new TypeError("Approximated data should be an array of points");if(3>a.length)throw new Error("Too little points. Approximation is impossible");a=a.slice().sort((a,b)=>a.r-b.r);let c=Number.POSITIVE_INFINITY,f=1;for(let{r:b,e:d}of a)d<c&&(c=d,f=b);c=Math.abs(c);let e,g;for(let b=1;b<a.length&&(e=a[b-1],g=a[b],!(g.r>=f||0>e.e||0>g.e));b++);let h;if(e&&g&&e.r<f&&g.r<=f){let a=e.e*(e.r-g.r)/(g.e-e.e)+e.r;0<a&&(h=f/(f-a))}return new d({d0:c,r0:f,b:h})}static from(a,{d0Conv:c=1e-3,r0Conv:d=1e-3,bConv:e=1e-3}={}){let f=this.fastFrom(a),{d0:g,r0:h,b:i}=f;const b=g*c,j=h*d,k=i*e;let l,m,n;do{let b=0,c=0,d=0,f=0,j=0,o=0,p=0,q=0,s=0;for(let{r:t,e:r}of a){let a=i*(t/h-1),e=Math.exp(-a),u=-g*(1+a)*e,k=u/g,l=-g*i*t/(h*h)*e*a,m=g*a/i*e*a;b+=k*k,c+=l*k,d+=m*k,f+=(u-r)*k,j+=l*l,o+=m*l,p+=(u-r)*l,q+=m*m,s+=(u-r)*m}n=-(f-b*p/c-(f-b*s/d)*((c-b*j/c)/(c-b*o/d)))/(d-b*o/c-(d-b*q/d)*(c-b*j/c)/(c-b*o/d)),m=((d-b*o/c)*n+(f-b*p/c))/(b*j/c-c),l=(-c*m-d*n-f)/b,g+=l,h+=m,i+=n}while(Math.abs(l)>b&&Math.abs(m)>j&&Math.abs(n)>k);return f.d0=g,f.r0=h,f.b=i,f}get d0(){return c.get(this).d0}set d0(a){if(!Number.isFinite(a))throw new TypeError("The 'd0' parameter should be a finite number");if(0>=a)throw new RangeError("The 'd0' parameter should be greater than zero");c.get(this).d0=a}get r0(){return c.get(this).r0}set r0(a){if(!Number.isFinite(a))throw new TypeError("The 'r0' parameter should be a finite number");if(0>=a)throw new RangeError("The 'r0' parameter should be greater than zero");c.get(this).r0=a}get b(){return c.get(this).b}set b(a){if(!Number.isFinite(a))throw new TypeError("The 'b' parameter should be a finite number");if(1>=a)throw new RangeError("The 'b' parameter should be greater than 1");c.get(this).b=a}at(a){if("number"!=typeof a)throw new TypeError("Distance should be a number");if(0>a)throw new RangeError("Distance shouldn't be less than zero");let{d0:c,r0:d,b:e}=this,b=e*(a-d)/d;return-c*(1+b)*Math.exp(-b)}toJSON(){return{type:"Rydberg",d0:this.d0,r0:this.r0,b:this.b}}}b.exports=d},{}],5:[function(a,b){let c=new WeakMap;class d{constructor({d0:a=1,r0:d=1,b:e=1}={}){c.set(this,{}),this.d0=a,this.r0=d,this.b=e}static fastFrom(a){if(!Array.isArray(a))throw new TypeError("Approximated data should be an array of points");if(3>a.length)throw new Error("Too little points. Approximation is impossible");let c=Number.POSITIVE_INFINITY,f=1;for(let{r:b,e:d}of a)d<c&&(c=d,f=b);c=Math.abs(c);let g=0,h=0;for(let{r:b,e:d}of a){let a=Math.sqrt(1+d/c),e=Number.NaN;b>f?e=Math.log(b/f*(1-a))/(f*f-b*b):b<f&&(e=Math.log(b/f*(1+a))/(f*f-b*b)),Number.isFinite(e)&&(g+=e,h++)}return g/=h,new d({d0:c,r0:f,b:g})}static from(a,{d0Conv:c=1e-3,r0Conv:d=1e-3,bConv:e=1e-3}={}){let f=this.fastFrom(a),{d0:g,r0:h,b:i}=f;const b=g*c,j=h*d,k=i*e;let l,m,n;do{let b=0,c=0,d=0,f=0,j=0,o=0,p=0,q=0,s=0;for(let{r:t,e:r}of a){let a=h/t*Math.exp(i*(h*h-t*t)),e=-g+g*(1-a)*(1-a),k=e/g,l=2*g*(1-a)*(-a/h-2*a*i*h),m=2*g*(1-a)*a*(t*t-h*h);b+=k*k,c+=l*k,d+=m*k,f+=(e-r)*k,j+=l*l,o+=m*l,p+=(e-r)*l,q+=m*m,s+=(e-r)*m}n=-(f-b*p/c-(f-b*s/d)*((c-b*j/c)/(c-b*o/d)))/(d-b*o/c-(d-b*q/d)*(c-b*j/c)/(c-b*o/d)),m=((d-b*o/c)*n+(f-b*p/c))/(b*j/c-c),l=(-c*m-d*n-f)/b,g+=l,h+=m,i+=n}while(Math.abs(l)>b&&Math.abs(m)>j&&Math.abs(n)>k);return f.d0=g,f.r0=h,f.b=i,f}get d0(){return c.get(this).d0}set d0(a){if(!Number.isFinite(a))throw new TypeError("The 'd0' parameter should be a finite number");if(0>=a)throw new RangeError("The 'd0' parameter should be greater than zero");c.get(this).d0=a}get r0(){return c.get(this).r0}set r0(a){if(!Number.isFinite(a))throw new TypeError("The 'r0' parameter should be a finite number");if(0>=a)throw new RangeError("The 'r0' parameter should be greater than zero");c.get(this).r0=a}get b(){return c.get(this).b}set b(a){if(!Number.isFinite(a))throw new TypeError("The 'b' parameter should be a finite number");if(0>=a)throw new RangeError("The 'b' parameter should be greater than zero");c.get(this).b=a}at(a){if("number"!=typeof a)throw new TypeError("Distance should be a number");if(0>a)throw new RangeError("Distance shouldn't be less than zero");let{d0:c,r0:d,b:e}=this,b=1-d/a*Math.exp(e*(d*d-a*a));return c*b*b-c}toJSON(){return{type:"Varshni3",d0:this.d0,r0:this.r0,b:this.b}}}b.exports=d},{}],6:[function(a,b){let c={LennardJones:a("./potentials/lennard-jones.js"),Buckingham:a("./potentials/buckingham.js"),Morse:a("./potentials/morse.js"),Rydberg:a("./potentials/rydberg.js"),Varshni3:a("./potentials/varshni3.js")};Object.defineProperty(c,"utils",{configurable:!0,value:a("./utils.js")}),b.exports=c},{"./potentials/buckingham.js":1,"./potentials/lennard-jones.js":2,"./potentials/morse.js":3,"./potentials/rydberg.js":4,"./potentials/varshni3.js":5,"./utils.js":7}],7:[function(a,b){b.exports={rSqr(a,b){let c=0,d=0;for(let{r:f,e:g}of a){c+=g;let a=g-b.at(f);d+=a*a}c/=a.length;let f=0;for(let{e:d}of a){let a=d-c;f+=a*a}return 1-d/f}}},{}]},{},[6])(6)});

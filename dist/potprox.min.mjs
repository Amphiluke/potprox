/*!
potprox v0.8.0
https://amphiluke.github.io/potprox/
*/
class r{rSqr(r){let t=0,e=0;for(let{r:i,e:s}of r){t+=s;let r=s-this.at(i);e+=r*r}t/=r.length;let i=0;for(let{e:e}of r){let r=e-t;i+=r*r}return 1-e/i}*points({start:r=this.r0/2,end:t=2*this.r0,step:e=(t-r)/49}={}){let i=0,s=r,o=Math.sign(t-r);for(e=Math.abs(e)*o;(t-s)*o>=0;)yield{r:s,e:this.at(s),index:i},s=r+e*++i;return{r:t,e:this.at(t)}}}const t="Too little points. Approximation is impossible",e="Approximated data must be an array of points",i=r=>`The “${r}” parameter must be a finite number`,s=(r,t=0)=>`The “${r}” parameter must be greater than ${t}`,o="Distance must be a number",n="Distance mustn’t be less than 0";let a=new WeakMap;class h extends r{constructor({epsilon:r=1,sigma:t=1}={}){super(),a.set(this,{}),this.epsilon=r,this.sigma=t}static get type(){return"LennardJones"}static from(r){if(!Array.isArray(r))throw new TypeError(e);if(r.length<3)throw new Error(t);let i=0,s=0,o=0,n=0,a=0;for(let{r:t,e:e}of r)i+=Math.pow(t,-24),s+=Math.pow(t,-18),o+=e*Math.pow(t,-12),n+=Math.pow(t,-12),a+=e*Math.pow(t,-6);let w=(a-s*o/i)/(n-s*s/i),f=(o-s*w)/i,l=Math.pow(-f/w,1/6),p=f/(4*Math.pow(l,12));return new h({epsilon:p,sigma:l})}get epsilon(){return a.get(this).epsilon}set epsilon(r){if(!Number.isFinite(r))throw new TypeError(i("epsilon"));if(r<=0)throw new RangeError(s("epsilon"));a.get(this).epsilon=r}get sigma(){return a.get(this).sigma}set sigma(r){if(!Number.isFinite(r))throw new TypeError(i("sigma"));if(r<=0)throw new RangeError(s("sigma"));a.get(this).sigma=r}get r0(){return 1.122462048309373*this.sigma}set r0(r){this.sigma=r/1.122462048309373}at(r){if("number"!=typeof r)throw new TypeError(o);if(r<0)throw new RangeError(n);let{epsilon:t,sigma:e}=this;return 4*t*(Math.pow(e/r,12)-Math.pow(e/r,6))}toJSON(){return{type:h.type,epsilon:this.epsilon,sigma:this.sigma}}}let w=new WeakMap;class f extends r{constructor({d0:r=1,r0:t=1,a:e=2}={}){super(),w.set(this,{}),this.d0=r,this.r0=t,this.a=e}static get type(){return"Buckingham"}static fastFrom(r){if(!Array.isArray(r))throw new TypeError(e);if(r.length<3)throw new Error(t);r=r.slice().sort((r,t)=>r.r-t.r);let i,s,o,n=Number.POSITIVE_INFINITY,a=1;for(let{r:t,e:e}of r)e<n&&(n=e,a=t);n=Math.abs(n);for(let t=1;t<r.length&&(i=r[t-1],s=r[t],!(s.r>=a||i.e<0||s.e<0));t++);if(i&&s&&i.r<a&&s.r<=a){let r=i.e*(i.r-s.r)/(s.e-i.e)+i.r;if(r>0){let t=1-r/a,e=Math.pow(a/r,6)/6;o=(e-t-Math.sqrt(e*e-2*t*e-t*t))/(t*t),Number.isFinite(o)||(o=void 0)}}return new f({d0:n,r0:a,a:o})}static from(r,{d0Conv:t=.001,r0Conv:e=.001,aConv:i=.001}={}){let s=this.fastFrom(r),{d0:o,r0:n,a:a}=s;const h=o*t,w=n*e,f=a*i;let l,p,g;do{let t=0,e=0,i=0,s=0,h=0,w=0,f=0,u=0,b=0;for(let{r:l,e:p}of r){let r=a*Math.pow(n/l,6),g=Math.exp(a*(1-l/n)),d=o/(a-6)*(6*g-r),m=d/o,y=o/(a-6)*(6*g*a*l/(n*n)-6*r/n),E=-o/((a-6)*(a-6))*(6*g-r)+o/(a-6)*(6*(1-l/n)*g-r/a);t+=m*m,e+=y*m,i+=E*m,s+=(d-p)*m,h+=y*y,w+=E*y,f+=(d-p)*y,u+=E*E,b+=(d-p)*E}g=-(s-t*f/e-(e-t*h/e)/(e-t*w/i)*(s-t*b/i))/(i-t*w/e-(i-t*u/i)*(e-t*h/e)/(e-t*w/i)),p=((i-t*w/e)*g+(s-t*f/e))/(t*h/e-e),l=(-e*p-i*g-s)/t,o+=l,n+=p,a+=g}while(Math.abs(l)>h&&Math.abs(p)>w&&Math.abs(g)>f);return s.d0=o,s.r0=n,s.a=a,s}get d0(){return w.get(this).d0}set d0(r){if(!Number.isFinite(r))throw new TypeError(i("d0"));if(r<=0)throw new RangeError(s("d0"));w.get(this).d0=r}get r0(){return w.get(this).r0}set r0(r){if(!Number.isFinite(r))throw new TypeError(i("r0"));if(r<=0)throw new RangeError(s("r0"));w.get(this).r0=r}get a(){return w.get(this).a}set a(r){if(!Number.isFinite(r))throw new TypeError(i("a"));if(r<=0)throw new RangeError(s("a"));w.get(this).a=r}at(r){if("number"!=typeof r)throw new TypeError(o);if(r<0)throw new RangeError(n);let{d0:t,r0:e,a:i}=this;return t/(i-6)*(6*Math.exp(i*(1-r/e))-i*Math.pow(e/r,6))}toJSON(){return{type:f.type,d0:this.d0,r0:this.r0,a:this.a}}}let l=new WeakMap;class p extends r{constructor({d0:r=1,r0:t=1,a:e=1}={}){super(),l.set(this,{}),this.d0=r,this.r0=t,this.a=e}static get type(){return"Morse"}static fastFrom(r){if(!Array.isArray(r))throw new TypeError(e);if(r.length<3)throw new Error(t);let i=Number.POSITIVE_INFINITY,s=1;for(let{r:t,e:e}of r)e<i&&(i=e,s=t);i=Math.abs(i);let o=0,n=0;for(let{r:t,e:e}of r){let r=Math.sqrt(1+e/i),a=Number.NaN;t>s?a=Math.log(1-r)/(s-t):t<s&&(a=Math.log(1+r)/(s-t)),Number.isFinite(a)&&(o+=a,n++)}return o/=n,new p({d0:i,r0:s,a:o})}static from(r,{d0Conv:t=.001,r0Conv:e=.001,aConv:i=.001}={}){let s=this.fastFrom(r),{d0:o,r0:n,a:a}=s;const h=o*t,w=n*e,f=a*i;let l,p,g;do{let t=0,e=0,i=0,s=0,h=0,w=0,f=0,u=0,b=0;for(let{r:l,e:p}of r){let r=Math.exp(a*(n-l)),g=o*(1-r)*(1-r)-o,d=g/o,m=-2*o*(1-r)*a*r,y=2*o*(1-r)*(l-n)*r;t+=d*d,e+=m*d,i+=y*d,s+=(g-p)*d,h+=m*m,w+=y*m,f+=(g-p)*m,u+=y*y,b+=(g-p)*y}g=-(s-t*f/e-(e-t*h/e)/(e-t*w/i)*(s-t*b/i))/(i-t*w/e-(i-t*u/i)*(e-t*h/e)/(e-t*w/i)),p=((i-t*w/e)*g+(s-t*f/e))/(t*h/e-e),l=(-e*p-i*g-s)/t,o+=l,n+=p,a+=g}while(Math.abs(l)>h&&Math.abs(p)>w&&Math.abs(g)>f);return s.d0=o,s.r0=n,s.a=a,s}get d0(){return l.get(this).d0}set d0(r){if(!Number.isFinite(r))throw new TypeError(i("d0"));if(r<=0)throw new RangeError(s("d0"));l.get(this).d0=r}get r0(){return l.get(this).r0}set r0(r){if(!Number.isFinite(r))throw new TypeError(i("r0"));if(r<=0)throw new RangeError(s("r0"));l.get(this).r0=r}get a(){return l.get(this).a}set a(r){if(!Number.isFinite(r))throw new TypeError(i("a"));if(r<=0)throw new RangeError(s("a"));l.get(this).a=r}at(r){if("number"!=typeof r)throw new TypeError(o);if(r<0)throw new RangeError(n);let{d0:t,r0:e,a:i}=this,s=1-Math.exp(i*(e-r));return t*s*s-t}toJSON(){return{type:p.type,d0:this.d0,r0:this.r0,a:this.a}}}let g=new WeakMap;class u extends r{constructor({d0:r=1,r0:t=1,b:e=2}={}){super(),g.set(this,{}),this.d0=r,this.r0=t,this.b=e}static get type(){return"Rydberg"}static fastFrom(r){if(!Array.isArray(r))throw new TypeError(e);if(r.length<3)throw new Error(t);r=r.slice().sort((r,t)=>r.r-t.r);let i,s,o,n=Number.POSITIVE_INFINITY,a=1;for(let{r:t,e:e}of r)e<n&&(n=e,a=t);n=Math.abs(n);for(let t=1;t<r.length&&(i=r[t-1],s=r[t],!(s.r>=a||i.e<0||s.e<0));t++);if(i&&s&&i.r<a&&s.r<=a){let r=i.e*(i.r-s.r)/(s.e-i.e)+i.r;r>0&&(o=a/(a-r))}return new u({d0:n,r0:a,b:o})}static from(r,{d0Conv:t=.001,r0Conv:e=.001,bConv:i=.001}={}){let s=this.fastFrom(r),{d0:o,r0:n,b:a}=s;const h=o*t,w=n*e,f=a*i;let l,p,g;do{let t=0,e=0,i=0,s=0,h=0,w=0,f=0,u=0,b=0;for(let{r:l,e:p}of r){let r=a*(l/n-1),g=Math.exp(-r),d=-o*(1+r)*g,m=d/o,y=-o*a*l/(n*n)*g*r,E=o*r/a*g*r;t+=m*m,e+=y*m,i+=E*m,s+=(d-p)*m,h+=y*y,w+=E*y,f+=(d-p)*y,u+=E*E,b+=(d-p)*E}g=-(s-t*f/e-(e-t*h/e)/(e-t*w/i)*(s-t*b/i))/(i-t*w/e-(i-t*u/i)*(e-t*h/e)/(e-t*w/i)),p=((i-t*w/e)*g+(s-t*f/e))/(t*h/e-e),l=(-e*p-i*g-s)/t,o+=l,n+=p,a+=g}while(Math.abs(l)>h&&Math.abs(p)>w&&Math.abs(g)>f);return s.d0=o,s.r0=n,s.b=a,s}get d0(){return g.get(this).d0}set d0(r){if(!Number.isFinite(r))throw new TypeError(i("d0"));if(r<=0)throw new RangeError(s("d0"));g.get(this).d0=r}get r0(){return g.get(this).r0}set r0(r){if(!Number.isFinite(r))throw new TypeError(i("r0"));if(r<=0)throw new RangeError(s("r0"));g.get(this).r0=r}get b(){return g.get(this).b}set b(r){if(!Number.isFinite(r))throw new TypeError(i("b"));if(r<=1)throw new RangeError(s("b",1));g.get(this).b=r}at(r){if("number"!=typeof r)throw new TypeError(o);if(r<0)throw new RangeError(n);let{d0:t,r0:e,b:i}=this,s=i*(r-e)/e;return-t*(1+s)*Math.exp(-s)}toJSON(){return{type:u.type,d0:this.d0,r0:this.r0,b:this.b}}}let b=new WeakMap;class d extends r{constructor({d0:r=1,r0:t=1,b:e=1}={}){super(),b.set(this,{}),this.d0=r,this.r0=t,this.b=e}static get type(){return"Varshni3"}static fastFrom(r){if(!Array.isArray(r))throw new TypeError(e);if(r.length<3)throw new Error(t);let i=Number.POSITIVE_INFINITY,s=1;for(let{r:t,e:e}of r)e<i&&(i=e,s=t);i=Math.abs(i);let o=0,n=0;for(let{r:t,e:e}of r){let r=Math.sqrt(1+e/i),a=Number.NaN;t>s?a=Math.log(t/s*(1-r))/(s*s-t*t):t<s&&(a=Math.log(t/s*(1+r))/(s*s-t*t)),Number.isFinite(a)&&(o+=a,n++)}return o/=n,new d({d0:i,r0:s,b:o})}static from(r,{d0Conv:t=.001,r0Conv:e=.001,bConv:i=.001}={}){let s=this.fastFrom(r),{d0:o,r0:n,b:a}=s;const h=o*t,w=n*e,f=a*i;let l,p,g;do{let t=0,e=0,i=0,s=0,h=0,w=0,f=0,u=0,b=0;for(let{r:l,e:p}of r){let r=n/l*Math.exp(a*(n*n-l*l)),g=o*(1-r)*(1-r)-o,d=g/o,m=2*o*(1-r)*(-r/n-2*r*a*n),y=2*o*(1-r)*r*(l*l-n*n);t+=d*d,e+=m*d,i+=y*d,s+=(g-p)*d,h+=m*m,w+=y*m,f+=(g-p)*m,u+=y*y,b+=(g-p)*y}g=-(s-t*f/e-(e-t*h/e)/(e-t*w/i)*(s-t*b/i))/(i-t*w/e-(i-t*u/i)*(e-t*h/e)/(e-t*w/i)),p=((i-t*w/e)*g+(s-t*f/e))/(t*h/e-e),l=(-e*p-i*g-s)/t,o+=l,n+=p,a+=g}while(Math.abs(l)>h&&Math.abs(p)>w&&Math.abs(g)>f);return s.d0=o,s.r0=n,s.b=a,s}get d0(){return b.get(this).d0}set d0(r){if(!Number.isFinite(r))throw new TypeError(i("d0"));if(r<=0)throw new RangeError(s("d0"));b.get(this).d0=r}get r0(){return b.get(this).r0}set r0(r){if(!Number.isFinite(r))throw new TypeError(i("r0"));if(r<=0)throw new RangeError(s("r0"));b.get(this).r0=r}get b(){return b.get(this).b}set b(r){if(!Number.isFinite(r))throw new TypeError(i("b"));if(r<=0)throw new RangeError(s("b"));b.get(this).b=r}at(r){if("number"!=typeof r)throw new TypeError(o);if(r<0)throw new RangeError(n);let{d0:t,r0:e,b:i}=this,s=1-e/r*Math.exp(i*(e*e-r*r));return t*s*s-t}toJSON(){return{type:d.type,d0:this.d0,r0:this.r0,b:this.b}}}export{f as Buckingham,h as LennardJones,p as Morse,u as Rydberg,d as Varshni3};

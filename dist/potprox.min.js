(function(c){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=c();else if("function"==typeof define&&define.amd)define([],c);else{var d;d="undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?this:self:global:window,d.potprox=c()}})(function(){return function j(p,q,v){function w(z,A){if(!q[z]){if(!p[z]){var B="function"==typeof require&&require;if(!A&&B)return B(z,!0);if(x)return x(z,!0);var C=new Error("Cannot find module '"+z+"'");throw C.code="MODULE_NOT_FOUND",C}var D=q[z]={exports:{}};p[z][0].call(D.exports,function(E){var F=p[z][1][E];return w(F?F:E)},D,D.exports,j,p,q,v)}return q[z].exports}for(var x="function"==typeof require&&require,y=0;y<v.length;y++)w(v[y]);return w}({1:[function(j,p){let v=new WeakMap;class w{constructor({epsilon:x=1,sigma:y=1}={}){v.set(this,{}),this.epsilon=x,this.sigma=y}static from(x){if(!Array.isArray(x))throw new TypeError("Approximated data should be an array of points");if(3>x.length)throw new Error("Too little points. Approximation is impossible");let y=0,z=0,A=0,B=0,C=0;for(let{r:H,e:I}of x)y+=Math.pow(H,-24),z+=Math.pow(H,-18),A+=I*Math.pow(H,-12),B+=Math.pow(H,-12),C+=I*Math.pow(H,-6);let D=(C-z*A/y)/(B-z*z/y),E=(A-z*D)/y,F=Math.pow(-E/D,1/6),G=E/(4*Math.pow(F,12));return new w({epsilon:G,sigma:F})}get epsilon(){return v.get(this).epsilon}set epsilon(x){if(!Number.isFinite(x))throw new TypeError("The 'epsilon' parameter should be a finite number");if(0>=x)throw new RangeError("The 'epsilon' parameter should be greater than zero");v.get(this).epsilon=x}get sigma(){return v.get(this).sigma}set sigma(x){if(!Number.isFinite(x))throw new TypeError("The 'sigma' parameter should be a finite number");if(0>=x)throw new RangeError("The 'sigma' parameter should be greater than zero");v.get(this).sigma=x}at(x){if("number"!=typeof x)throw new TypeError("Distance should be a number");if(0>x)throw new RangeError("Distance shouldn't be less than zero");let{epsilon:y,sigma:z}=this;return 4*y*(Math.pow(z/x,12)-Math.pow(z/x,6))}toJSON(){return{epsilon:this.epsilon,sigma:this.sigma}}}p.exports=w},{}],2:[function(j,p){let v=new WeakMap;class w{constructor({d0:x=1,r0:y=1,a:z=1}={}){v.set(this,{}),this.d0=x,this.r0=y,this.a=z}static fastFrom(x){if(!Array.isArray(x))throw new TypeError("Approximated data should be an array of points");if(3>x.length)throw new Error("Too little points. Approximation is impossible");let y=Number.POSITIVE_INFINITY,z=1;for(let{r:C,e:D}of x)D<y&&(y=D,z=C);y=Math.abs(y);let A=0,B=0;for(let{r:C,e:D}of x){let E=Math.sqrt(1+D/y),F=Number.NaN;C>z?F=Math.log(1-E)/(z-C):C<z&&(F=Math.log(1+E)/(z-C)),Number.isFinite(F)&&(A+=F,B++)}return A/=B,new w({d0:y,r0:z,a:A})}static from(x){let y=this.fastFrom(x),{d0:z,r0:A,a:B}=y;const C=z/1e3,D=A/1e3,E=B/1e3;let F,G,H;do{let I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0;for(let{r:R,e:S}of x){let T=Math.exp(B*(A-R)),U=-z+z*(1-T)*(1-T),V=(1-T)*(1-T)-1,W=-2*z*(1-T)*B*T,X=2*z*(1-T)*(R-A)*T;I+=V*V,J+=W*V,K+=X*V,L+=(U-S)*V,M+=W*W,N+=X*W,O+=(U-S)*W,P+=X*X,Q+=(U-S)*X}H=-(L-I*O/J-(L-I*Q/K)*((J-I*M/J)/(J-I*N/K)))/(K-I*N/J-(K-I*P/K)*(J-I*M/J)/(J-I*N/K)),G=((K-I*N/J)*H+(L-I*O/J))/(I*M/J-J),F=(-J*G-K*H-L)/I,z+=F,A+=G,B+=H}while(Math.abs(F)>C&&Math.abs(G)>D&&Math.abs(H)>E);return y.d0=z,y.r0=A,y.a=B,y}get d0(){return v.get(this).d0}set d0(x){if(!Number.isFinite(x))throw new TypeError("The 'd0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'd0' parameter should be greater than zero");v.get(this).d0=x}get r0(){return v.get(this).r0}set r0(x){if(!Number.isFinite(x))throw new TypeError("The 'r0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'r0' parameter should be greater than zero");v.get(this).r0=x}get a(){return v.get(this).a}set a(x){if(!Number.isFinite(x))throw new TypeError("The 'a' parameter should be a finite number");if(0>=x)throw new RangeError("The 'a' parameter should be greater than zero");v.get(this).a=x}at(x){if("number"!=typeof x)throw new TypeError("Distance should be a number");if(0>x)throw new RangeError("Distance shouldn't be less than zero");let{d0:y,r0:z,a:A}=this,B=1-Math.exp(A*(z-x));return y*B*B-y}toJSON(){return{d0:this.d0,r0:this.r0,a:this.a}}}p.exports=w},{}],3:[function(j,p){let v=new WeakMap;class w{constructor({d0:x=1,r0:y=1,b:z=2}={}){v.set(this,{}),this.d0=x,this.r0=y,this.b=z}static fastFrom(x){if(!Array.isArray(x))throw new TypeError("Approximated data should be an array of points");if(3>x.length)throw new Error("Too little points. Approximation is impossible");x=x.slice().sort((D,E)=>D.r-E.r);let y=Number.POSITIVE_INFINITY,z=1;for(let{r:D,e:E}of x)E<y&&(y=E,z=D);y=Math.abs(y);let A,B;for(let D=1;D<x.length&&(A=x[D-1],B=x[D],!(B.r>=z||0>A.e||0>B.e));D++);let C;if(A&&B&&A.r<z&&B.r<=z){let D=A.e*(A.r-B.r)/(B.e-A.e)+A.r;0<D&&(C=z/(z-D))}return new w({d0:y,r0:z,b:C})}static from(x){let y=this.fastFrom(x),{d0:z,r0:A,b:B}=y;const C=z/1e3,D=A/1e3,E=B/1e3;let F,G,H;do{let I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0;for(let{r:R,e:S}of x){let T=B*(R/A-1),U=Math.exp(-T),V=-z*(1+T)*U,W=(-1-T)*U,X=-z*B*R/(A*A)*U*T,Y=z*T/B*U*T;I+=W*W,J+=X*W,K+=Y*W,L+=(V-S)*W,M+=X*X,N+=Y*X,O+=(V-S)*X,P+=Y*Y,Q+=(V-S)*Y}H=-(L-I*O/J-(L-I*Q/K)*((J-I*M/J)/(J-I*N/K)))/(K-I*N/J-(K-I*P/K)*(J-I*M/J)/(J-I*N/K)),G=((K-I*N/J)*H+(L-I*O/J))/(I*M/J-J),F=(-J*G-K*H-L)/I,z+=F,A+=G,B+=H}while(Math.abs(F)>C&&Math.abs(G)>D&&Math.abs(H)>E);return y.d0=z,y.r0=A,y.b=B,y}get d0(){return v.get(this).d0}set d0(x){if(!Number.isFinite(x))throw new TypeError("The 'd0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'd0' parameter should be greater than zero");v.get(this).d0=x}get r0(){return v.get(this).r0}set r0(x){if(!Number.isFinite(x))throw new TypeError("The 'r0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'r0' parameter should be greater than zero");v.get(this).r0=x}get b(){return v.get(this).b}set b(x){if(!Number.isFinite(x))throw new TypeError("The 'b' parameter should be a finite number");if(1>=x)throw new RangeError("The 'b' parameter should be greater than 1");v.get(this).b=x}at(x){if("number"!=typeof x)throw new TypeError("Distance should be a number");if(0>x)throw new RangeError("Distance shouldn't be less than zero");let{d0:y,r0:z,b:A}=this,B=A*(x-z)/z;return-y*(1+B)*Math.exp(-B)}toJSON(){return{d0:this.d0,r0:this.r0,b:this.b}}}p.exports=w},{}],4:[function(j,p){let v={LennardJones:j("./potentials/lennard-jones.js"),Morse:j("./potentials/morse.js"),Rydberg:j("./potentials/rydberg.js")};p.exports=v},{"./potentials/lennard-jones.js":1,"./potentials/morse.js":2,"./potentials/rydberg.js":3}]},{},[4])(4)});

(function(c){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=c();else if("function"==typeof define&&define.amd)define([],c);else{var d;d="undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?this:self:global:window,d.potprox=c()}})(function(){return function j(p,q,v){function w(z,C){if(!q[z]){if(!p[z]){var D="function"==typeof require&&require;if(!C&&D)return D(z,!0);if(x)return x(z,!0);var E=new Error("Cannot find module '"+z+"'");throw E.code="MODULE_NOT_FOUND",E}var F=q[z]={exports:{}};p[z][0].call(F.exports,function(G){var H=p[z][1][G];return w(H?H:G)},F,F.exports,j,p,q,v)}return q[z].exports}for(var x="function"==typeof require&&require,y=0;y<v.length;y++)w(v[y]);return w}({1:[function(j,p){let v=new WeakMap;class w{constructor({d0:x=1,r0:y=1,a:z=2}={}){v.set(this,{}),this.d0=x,this.r0=y,this.a=z}static fastFrom(x){if(!Array.isArray(x))throw new TypeError("Approximated data should be an array of points");if(3>x.length)throw new Error("Too little points. Approximation is impossible");x=x.slice().sort((F,G)=>F.r-G.r);let y=Number.POSITIVE_INFINITY,z=1;for(let{r:F,e:G}of x)G<y&&(y=G,z=F);y=Math.abs(y);let C,D;for(let F=1;F<x.length&&(C=x[F-1],D=x[F],!(D.r>=z||0>C.e||0>D.e));F++);let E;if(C&&D&&C.r<z&&D.r<=z){let F=C.e*(C.r-D.r)/(D.e-C.e)+C.r;if(0<F){let G=1-F/z,H=Math.pow(z/F,6)/6;E=(H-G-Math.sqrt(H*H-2*G*H-G*G))/(G*G),Number.isFinite(E)||(E=void 0)}}return new w({d0:y,r0:z,a:E})}static from(x){let y=this.fastFrom(x),{d0:z,r0:C,a:D}=y;const E=z/1e3,F=C/1e3,G=D/1e3;let H,I,J;do{let K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0;for(let{r:T,e:U}of x){let V=D*Math.pow(C/T,6),W=Math.exp(D*(1-T/C)),X=z/(D-6)*(6*W-V),Y=X/z,Z=z/(D-6)*(6*W*D*T/(C*C)-6*V/C),$=-z/((D-6)*(D-6))*(6*W-V)+z/(D-6)*(6*(1-T/C)*W-V/D);K+=Y*Y,L+=Z*Y,M+=$*Y,N+=(X-U)*Y,O+=Z*Z,P+=$*Z,Q+=(X-U)*Z,R+=$*$,S+=(X-U)*$}J=-(N-K*Q/L-(N-K*S/M)*((L-K*O/L)/(L-K*P/M)))/(M-K*P/L-(M-K*R/M)*(L-K*O/L)/(L-K*P/M)),I=((M-K*P/L)*J+(N-K*Q/L))/(K*O/L-L),H=(-L*I-M*J-N)/K,z+=H,C+=I,D+=J}while(Math.abs(H)>E&&Math.abs(I)>F&&Math.abs(J)>G);return y.d0=z,y.r0=C,y.a=D,y}get d0(){return v.get(this).d0}set d0(x){if(!Number.isFinite(x))throw new TypeError("The 'd0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'd0' parameter should be greater than zero");v.get(this).d0=x}get r0(){return v.get(this).r0}set r0(x){if(!Number.isFinite(x))throw new TypeError("The 'r0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'r0' parameter should be greater than zero");v.get(this).r0=x}get a(){return v.get(this).a}set a(x){if(!Number.isFinite(x))throw new TypeError("The 'a' parameter should be a finite number");if(0>=x)throw new RangeError("The 'a' parameter should be greater than 0");v.get(this).a=x}at(x){if("number"!=typeof x)throw new TypeError("Distance should be a number");if(0>x)throw new RangeError("Distance shouldn't be less than zero");let{d0:y,r0:z,a:C}=this;return y/(C-6)*(6*Math.exp(C*(1-x/z))-C*Math.pow(z/x,6))}toJSON(){return{d0:this.d0,r0:this.r0,a:this.a}}}p.exports=w},{}],2:[function(j,p){let v=new WeakMap;class w{constructor({epsilon:x=1,sigma:y=1}={}){v.set(this,{}),this.epsilon=x,this.sigma=y}static from(x){if(!Array.isArray(x))throw new TypeError("Approximated data should be an array of points");if(3>x.length)throw new Error("Too little points. Approximation is impossible");let y=0,z=0,C=0,D=0,E=0;for(let{r:J,e:K}of x)y+=Math.pow(J,-24),z+=Math.pow(J,-18),C+=K*Math.pow(J,-12),D+=Math.pow(J,-12),E+=K*Math.pow(J,-6);let F=(E-z*C/y)/(D-z*z/y),G=(C-z*F)/y,H=Math.pow(-G/F,1/6),I=G/(4*Math.pow(H,12));return new w({epsilon:I,sigma:H})}get epsilon(){return v.get(this).epsilon}set epsilon(x){if(!Number.isFinite(x))throw new TypeError("The 'epsilon' parameter should be a finite number");if(0>=x)throw new RangeError("The 'epsilon' parameter should be greater than zero");v.get(this).epsilon=x}get sigma(){return v.get(this).sigma}set sigma(x){if(!Number.isFinite(x))throw new TypeError("The 'sigma' parameter should be a finite number");if(0>=x)throw new RangeError("The 'sigma' parameter should be greater than zero");v.get(this).sigma=x}at(x){if("number"!=typeof x)throw new TypeError("Distance should be a number");if(0>x)throw new RangeError("Distance shouldn't be less than zero");let{epsilon:y,sigma:z}=this;return 4*y*(Math.pow(z/x,12)-Math.pow(z/x,6))}toJSON(){return{epsilon:this.epsilon,sigma:this.sigma}}}p.exports=w},{}],3:[function(j,p){let v=new WeakMap;class w{constructor({d0:x=1,r0:y=1,a:z=1}={}){v.set(this,{}),this.d0=x,this.r0=y,this.a=z}static fastFrom(x){if(!Array.isArray(x))throw new TypeError("Approximated data should be an array of points");if(3>x.length)throw new Error("Too little points. Approximation is impossible");let y=Number.POSITIVE_INFINITY,z=1;for(let{r:E,e:F}of x)F<y&&(y=F,z=E);y=Math.abs(y);let C=0,D=0;for(let{r:E,e:F}of x){let G=Math.sqrt(1+F/y),H=Number.NaN;E>z?H=Math.log(1-G)/(z-E):E<z&&(H=Math.log(1+G)/(z-E)),Number.isFinite(H)&&(C+=H,D++)}return C/=D,new w({d0:y,r0:z,a:C})}static from(x){let y=this.fastFrom(x),{d0:z,r0:C,a:D}=y;const E=z/1e3,F=C/1e3,G=D/1e3;let H,I,J;do{let K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0;for(let{r:T,e:U}of x){let V=Math.exp(D*(C-T)),W=-z+z*(1-V)*(1-V),X=W/z,Y=-2*z*(1-V)*D*V,Z=2*z*(1-V)*(T-C)*V;K+=X*X,L+=Y*X,M+=Z*X,N+=(W-U)*X,O+=Y*Y,P+=Z*Y,Q+=(W-U)*Y,R+=Z*Z,S+=(W-U)*Z}J=-(N-K*Q/L-(N-K*S/M)*((L-K*O/L)/(L-K*P/M)))/(M-K*P/L-(M-K*R/M)*(L-K*O/L)/(L-K*P/M)),I=((M-K*P/L)*J+(N-K*Q/L))/(K*O/L-L),H=(-L*I-M*J-N)/K,z+=H,C+=I,D+=J}while(Math.abs(H)>E&&Math.abs(I)>F&&Math.abs(J)>G);return y.d0=z,y.r0=C,y.a=D,y}get d0(){return v.get(this).d0}set d0(x){if(!Number.isFinite(x))throw new TypeError("The 'd0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'd0' parameter should be greater than zero");v.get(this).d0=x}get r0(){return v.get(this).r0}set r0(x){if(!Number.isFinite(x))throw new TypeError("The 'r0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'r0' parameter should be greater than zero");v.get(this).r0=x}get a(){return v.get(this).a}set a(x){if(!Number.isFinite(x))throw new TypeError("The 'a' parameter should be a finite number");if(0>=x)throw new RangeError("The 'a' parameter should be greater than zero");v.get(this).a=x}at(x){if("number"!=typeof x)throw new TypeError("Distance should be a number");if(0>x)throw new RangeError("Distance shouldn't be less than zero");let{d0:y,r0:z,a:C}=this,D=1-Math.exp(C*(z-x));return y*D*D-y}toJSON(){return{d0:this.d0,r0:this.r0,a:this.a}}}p.exports=w},{}],4:[function(j,p){let v=new WeakMap;class w{constructor({d0:x=1,r0:y=1,b:z=2}={}){v.set(this,{}),this.d0=x,this.r0=y,this.b=z}static fastFrom(x){if(!Array.isArray(x))throw new TypeError("Approximated data should be an array of points");if(3>x.length)throw new Error("Too little points. Approximation is impossible");x=x.slice().sort((F,G)=>F.r-G.r);let y=Number.POSITIVE_INFINITY,z=1;for(let{r:F,e:G}of x)G<y&&(y=G,z=F);y=Math.abs(y);let C,D;for(let F=1;F<x.length&&(C=x[F-1],D=x[F],!(D.r>=z||0>C.e||0>D.e));F++);let E;if(C&&D&&C.r<z&&D.r<=z){let F=C.e*(C.r-D.r)/(D.e-C.e)+C.r;0<F&&(E=z/(z-F))}return new w({d0:y,r0:z,b:E})}static from(x){let y=this.fastFrom(x),{d0:z,r0:C,b:D}=y;const E=z/1e3,F=C/1e3,G=D/1e3;let H,I,J;do{let K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0;for(let{r:T,e:U}of x){let V=D*(T/C-1),W=Math.exp(-V),X=-z*(1+V)*W,Y=X/z,Z=-z*D*T/(C*C)*W*V,$=z*V/D*W*V;K+=Y*Y,L+=Z*Y,M+=$*Y,N+=(X-U)*Y,O+=Z*Z,P+=$*Z,Q+=(X-U)*Z,R+=$*$,S+=(X-U)*$}J=-(N-K*Q/L-(N-K*S/M)*((L-K*O/L)/(L-K*P/M)))/(M-K*P/L-(M-K*R/M)*(L-K*O/L)/(L-K*P/M)),I=((M-K*P/L)*J+(N-K*Q/L))/(K*O/L-L),H=(-L*I-M*J-N)/K,z+=H,C+=I,D+=J}while(Math.abs(H)>E&&Math.abs(I)>F&&Math.abs(J)>G);return y.d0=z,y.r0=C,y.b=D,y}get d0(){return v.get(this).d0}set d0(x){if(!Number.isFinite(x))throw new TypeError("The 'd0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'd0' parameter should be greater than zero");v.get(this).d0=x}get r0(){return v.get(this).r0}set r0(x){if(!Number.isFinite(x))throw new TypeError("The 'r0' parameter should be a finite number");if(0>=x)throw new RangeError("The 'r0' parameter should be greater than zero");v.get(this).r0=x}get b(){return v.get(this).b}set b(x){if(!Number.isFinite(x))throw new TypeError("The 'b' parameter should be a finite number");if(1>=x)throw new RangeError("The 'b' parameter should be greater than 1");v.get(this).b=x}at(x){if("number"!=typeof x)throw new TypeError("Distance should be a number");if(0>x)throw new RangeError("Distance shouldn't be less than zero");let{d0:y,r0:z,b:C}=this,D=C*(x-z)/z;return-y*(1+D)*Math.exp(-D)}toJSON(){return{d0:this.d0,r0:this.r0,b:this.b}}}p.exports=w},{}],5:[function(j,p){let v={LennardJones:j("./potentials/lennard-jones.js"),Buckingham:j("./potentials/buckingham.js"),Morse:j("./potentials/morse.js"),Rydberg:j("./potentials/rydberg.js")};p.exports=v},{"./potentials/buckingham.js":1,"./potentials/lennard-jones.js":2,"./potentials/morse.js":3,"./potentials/rydberg.js":4}]},{},[5])(5)});
